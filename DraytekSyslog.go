package DraytekSyslog

import (
	//"encoding/binary"
	"flag"
	"fmt"
	//	"io/ioutil"
	//	"log"
	"database/sql"
	"net"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"
	"crypto/md5"
	_ "encoding/hex"

	"./sqlite3lib"
	"encoding/hex"
)

var (
	//newFile     *os.File
	//err         error
	syslogIP    string //currentserver ip, if not correct, ignore msg
	isDBcreated bool   //check if db created, if not, create
	DNSUpdateRunning bool
)

var host = flag.String("host", "0.0.0.0", "host")
var port = flag.String("port", "514", "port")
var IPrefix = []string {"192.168.188","192.168.1"}
var IPmap = make(map[string]int)
const dbpath = "syslogs.db"

/*
Logtype:
150 userlog - nat,dns,wireless
158 load balance log
134 firewalllog
174 status
166 wan log
141 vpn log
181 dhcp log <181>Sep 25 09:18:44 DrayTek_TEST: [DHCP] Vigor DHCP server has given out an IP [MAC: f4-31-c3-01-f4-ea, IP: 192.168.1.12]
its own id: otherlog
129 2017-09-27 10:27:47　Sep 27 10:27:50 DrayTek_TEST [DOS][Block][fraggle_attack][192.168.1.10:68->255.255.255.255:67][UDP][HLen=20, TLen=328]

subtype:
51 nat
52 NAT close session
53 dns
54 wireless
61 LCP
62 WAN drop
63 WAN up9 userlog - loadbalance

*/

func main() {
	sqlite3lib.DNSUpdateRunning = false
	fmt.Println(IPrefix)
	syslogIP = ""
	db := sqlite3lib.InitDB(dbpath)
	defer db.Close()
	if isDBcreated == false {
		sqlite3lib.CreateTable(db)
		isDBcreated = true

		//fmt.Println("-+-+-+-+-+-+-+")
	}
	users:=sqlite3lib.IPmapInit(db)
	for _,userr:=range users{
		k:=GetMD5Hash8(userr.IP + userr.MAC)
		v,_:=strconv.Atoi(userr.Id)
		IPmap[k]=v
	}
	flag.Parse()
	addr, err := net.ResolveUDPAddr("udp", *host+":"+*port)
	if err != nil {
		fmt.Println("Can't resolve address: ", err)
		os.Exit(1)
	}
	conn, err := net.ListenUDP("udp", addr)
	if err != nil {
		fmt.Println("Error listening:", err)
		os.Exit(1)
	}
	createFile("syslog.txt")
	createFile("programlog.txt")

	defer conn.Close()
	for {
		handleClient(conn, db)
	}
}
func handleClient(conn *net.UDPConn, db *sql.DB) {
	data := make([]byte, 1024)
	n, remoteAddr, err := conn.ReadFromUDP(data)
	if err != nil {
		fmt.Println("failed to read UDP msg because of ", err.Error())
		return
	}
	//	daytime := time.Now().Unix()
	fmt.Println(n, remoteAddr)

	if syslogIP == ""{
		syslogIP = remoteAddr.String()
	}

	//第一次收到syslog包即完成了router ip绑定，如果新来的包不是来自于该IP，则忽略掉，因为目前只支持一个router
	if remoteAddr.String() != syslogIP {
		fmt.Println("New router ip from", remoteAddr.String(), "ignore!")
		return
	}
	var logmsg string
	var logtype string
	//	var logtime string
	//	var msgbody string
	//	var msgslices []string
	//	var logrouterip string
	logmsg = strings.Trim(fmt.Sprintf("%s", data[:n]), "\n")
	logtype = string(data[1:4])
	switch logtype {
	case "150":
		userLogHandle(logmsg, db)
	case "158":
		lbLogHandle(logmsg)
	case "129":
		fwLogHandle(logmsg, 129)
	case "134":
		fwLogHandle(logmsg, 134)
	case "174":
		stHandle(logmsg)
	case "166":
		wanHandle(logmsg)
	case "141":
		vpnHandle(logmsg)
	default:
		fmt.Println(logtype)
		othHandle(logmsg)
	}

	/*
		logtime = strings.Trim(string(data[5:20]), " ")
		msgbody = strings.Trim(string(data[20:n]), " ")
		msgslices = strings.Split(msgbody, " ")
		fmt.Println(msgslices[0], len(msgslices))
		//print each item of msg slices generated by strings.Split
		for i := 0; i < len(msgslices); i++ {
			fmt.Println(msgslices[i])
		}
		fmt.Println(logtype, logtime, msgbody)
	*/
	logmsg = fmt.Sprintf("%s\r\n", logmsg)
	fmt.Println(logmsg)
	f, err := os.OpenFile("syslog.txt", os.O_APPEND, 0666)
	if err != nil {
		panic(err)
	}
	f.WriteString(logmsg)
	f.Close()
	//	b := make([]byte, 4)
	//	binary.BigEndian.PutUint32(b, uint32(daytime))
	//	conn.WriteToUDP(b, remoteAddr)
}

func createFile(path string) {
	// detect if file exists
	var _, err = os.Stat(path)

	// create file if not exists
	if os.IsNotExist(err) {
		var file, err = os.Create(path)
		if isError(err) {
			fmt.Println("==> done creating file", path)
			return
		}
		defer file.Close()
	}
	fmt.Println("==File exist, continue writing==")

}

func isError(err error) bool {
	if err != nil {
		fmt.Println(err.Error())
	}

	return (err != nil)
}
func userLogHandle(l string, db *sql.DB) bool {
	//	fmt.Println("+++++++", 150)
	fmt.Println("what is your map",IPmap)
	var syslogitem sqlite3lib.SyslogItem
	syslogitem.Id = ""
	syslogitem.Logtype = "150"
	syslogitem.Subtype = "0" //default 0
	syslogitem.Sysdate = time.Now().Format("2006-01-02 15:04:05")
	syslogitem.Routerdate = strings.Trim(string(l[5:20]), " ")
	//msg body total, not for struct
	msgbody := strings.Trim(string(l[20:]), " ")
	msgslices := strings.Split(msgbody, " ")
	//continue structure var
	syslogitem.Routername = msgslices[0][0 : len(msgslices[0])-1]
	syslogitem.Msgbody = msgbody[len(syslogitem.Routername)+2:]
	syslogitem.MacAddr = findmac(l)
	if syslogitem.MacAddr == "no" {
		syslogitem.MacAddr = ""
	}
	syslogitem.Domain = findDomain(l)
	if syslogitem.Domain == "no" {
		syslogitem.Domain = ""
		syslogitem.Subtype = "51"
	} else { //is a DNS auery
		syslogitem.Subtype = "53"
	}
	syslogitem.SrcIP = ""
	syslogitem.DstIP = ""
	syslogitem.SrcPort = ""
	syslogitem.DstPort = ""
	syslogitem.SrcIPi = 0
	syslogitem.DstIPi = 0
	syslogitem.IPlink = ""
	IPaddresses := findIP(l)
	if len(IPaddresses) == 2 { // nat session or dns query
		syslogitem.SrcIP = IPaddresses[0]
		syslogitem.DstIP = IPaddresses[1]
		if IsLocalIP(syslogitem.SrcIP,IPrefix){
			macip:=syslogitem.MacAddr+syslogitem.SrcIP
			maciphash := GetMD5Hash8(macip)
			if _, ok := IPmap[maciphash]; !ok {
				//not in map
				NewUser := sqlite3lib.User{Id:"0",MAC:syslogitem.MacAddr,IP:syslogitem.SrcIP,Name:""}
				fmt.Println(NewUser)
				insertid:=sqlite3lib.StoreUser(db,NewUser)
				IPmap[maciphash]=int(insertid)
				syslogitem.IPlink = strconv.Itoa(int(insertid))
				//change value to 0 to indicate there is exist user in usertable to refer
				syslogitem.IPlink = strconv.Itoa(IPmap[maciphash])
				fmt.Println("iplinke id is ",syslogitem.IPlink)

			} else{//in map
				syslogitem.SrcIP = "0"
				syslogitem.MacAddr = "0"
				syslogitem.IPlink = strconv.Itoa(IPmap[maciphash])
				fmt.Println("iplinke id is ",syslogitem.IPlink)
			}

		}
		if syslogitem.Domain != "" { //is a DNS query
			syslogitem.Subtype = "53"
			for i:=0;i<100;i++{
				go ResDN(syslogitem.Domain)
			}

			//			fmt.Println(SrcPort, DstPort)
		} else { //is a NAT session
			syslogitem.Msgbody = ""
			ports := FindPort(l, syslogitem.SrcIP)
			if len(ports) == 2 { //find ports for NAT session
				syslogitem.SrcPort = ports[0]
				syslogitem.DstPort = ports[1]
				//				fmt.Println(syslogitem.SrcPort, syslogitem.DstPort)
			}
			if findCloseConn(l) == true {
				syslogitem.Subtype = "52"
			} else {
				syslogitem.Subtype = "51"
			}

		}
		syslogitem.SrcIPi = Ip2long(syslogitem.SrcIP)
		syslogitem.DstIPi = Ip2long(syslogitem.DstIP)
		//		fmt.Println(SrcIPi, DstIPi)
	} else { //other local message
		//check wireless
		if findWlan(l) == true { //is wireless
			syslogitem.Subtype = "54"

			//			fmt.Println(SrcIPi, DstIPi, SrcIP, DstIP)
			//			fmt.Println(SrcPort, DstPort)
		}
	}
	syslogitem.Prot = findProt(l) //1-tcp 2-udp 3-dns 4-icmp 0-other
	sqlite3lib.StoreItem(db, syslogitem)
	fmt.Println(syslogitem)

	return true
}
func lbLogHandle(l string) bool {
	fmt.Println("+++++++", 158)
	return true
}
func fwLogHandle(l string, t int) bool {
	switch t {
	case 129:
		fmt.Println("ddos log")
	case 134:
		fmt.Println("FILTER BLOCK")
		//<134>Sep 27 16:51:29 DrayTek_TEST: [FILTER][Block][LAN/RT/VPN->WAN, 121:45:04    ][@S:R=2:2, 192.168.188.10:53072->176.34.105.234:8443][TCP][HLen=20, TLen=52, Flag=S, Seq=2902598136, Ack=0, Win=64240]
	}

	fmt.Println("+++++++ddos", 129)
	return true
}
func stHandle(l string) bool {
	return true
}
func wanHandle(l string) bool {
	return true
}
func vpnHandle(l string) bool {
	return true
}
func othHandle(l string) bool {
	fmt.Println("-------other--------")
	return true
}

func findmac(m string) string {
	pos := strings.Index(m, "(MAC=")
	if pos > -1 {
		mac := m[pos+5 : pos+22]
		return mac
	} else {
		return "no"
	}

}

func findDomain(m string) string {
	pos := strings.Index(m, " inquire ")
	if pos > -1 {
		dn := m[pos+9:]
		dn = strings.TrimRight(dn, " ")
		return dn
	} else {
		return "no"
	}

}

func findIP(m string) []string {
	numBlock := "(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])"
	regexPattern := numBlock + "\\." + numBlock + "\\." + numBlock + "\\." + numBlock
	regEx := regexp.MustCompile(regexPattern)
	ipaddrs := regEx.FindAllString(m, -1)
	if ipaddrs != nil {
		return ipaddrs
	} else {
		return nil
	}

}

func FindPort(m string, s string) []string {
	pos := strings.Index(m, s)
	if pos > -1 { //find srcip
		remain := m[pos:]
		remainslice := strings.Split(remain, " -> ")
		if len(remainslice) == 2 {
			sport := strings.Split(remainslice[0], ":")
			protopos := strings.Index(remainslice[1], " ")
			dport := strings.Split(remainslice[1][0:protopos], ":")
			if len(sport) == 2 && len(dport) == 2 {
				var ports []string
				ports = append(ports, sport[1], dport[1])
				return ports
			} else {
				return nil
			}

		} else {
			return nil
		}
	} else {
		return nil
	}
}

func findCloseConn(m string) bool {
	pos := strings.Index(m, "close connection")
	if pos > -1 {
		return true
	}
	return false
}

func findWlan(m string) bool { //return msg body
	pos := strings.Index(m, "[WLAN]")
	if pos > -1 { //find wlan tag
		return true
	}
	pos = strings.Index(m, "WLAN_DBG")
	if pos > -1 {
		return true
	}
	return false
}

func findProt(m string) uint8 {
	//1-tcp 2-udp 3-dns 4-icmp 0-other
	pos := strings.Index(m, "(TCP)")
	if pos > -1 {
		return 1
	}
	pos = strings.Index(m, "(UDP)")
	if pos > -1 {
		return 2
	}
	pos = strings.Index(m, "DNS ->")
	if pos > -1 {
		return 3
	}
	pos = strings.Index(m, "ICMP")
	if pos > -1 {
		return 4
	}
	return 0
}
func Ip2long(ipstr string) (ip uint32) {
	r := `^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})`
	reg, err := regexp.Compile(r)
	if err != nil {
		return
	}
	ips := reg.FindStringSubmatch(ipstr)
	if ips == nil {
		return
	}

	ip1, _ := strconv.Atoi(ips[1])
	ip2, _ := strconv.Atoi(ips[2])
	ip3, _ := strconv.Atoi(ips[3])
	ip4, _ := strconv.Atoi(ips[4])

	if ip1 > 255 || ip2 > 255 || ip3 > 255 || ip4 > 255 {
		return
	}

	ip += uint32(ip1 * 0x1000000)
	ip += uint32(ip2 * 0x10000)
	ip += uint32(ip3 * 0x100)
	ip += uint32(ip4)

	return
}
func Long2ip(ip uint32) string {
	return fmt.Sprintf("%d.%d.%d.%d", ip>>24, ip<<8>>24, ip<<16>>24, ip<<24>>24)
}

func ResDN(dn string) bool{
	db1 := sqlite3lib.InitDB(dbpath)
	defer db1.Close()
	addresses, err := net.LookupIP(dn)
	if err == nil {
		//length := len(addresses)
		var iplist []string
		for _, ipaddr := range addresses {
			x := ipaddr.String()
			iplist = append(iplist,x)
			//fmt.Println(iplist)
		}
		dnstruct := sqlite3lib.DomainItem{Domain: dn, IP: iplist}
		sqlite3lib.StoreDnsItems(db1, dnstruct)
		//if sqlite3lib.DNSUpdateRunning==false{
		//	sqlite3lib.UpdateDomain(db1)
		//}
	}
	return true
}
func GetMD5Hash8(text string) string {
	hasher := md5.New()
	hasher.Write([]byte(text))
	return hex.EncodeToString(hasher.Sum(nil))[:8]
}
func IsLocalIP(s string, prefixips []string) bool{
	for _,preip:=range prefixips {
		if strings.Contains(s, preip)==true{
			return true
		}
	}
	return false
}